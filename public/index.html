<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Multiplayer Game</title>
  <style>
    /* 1. RESET & LAYOUT */
    body, html { margin: 0; padding: 0; font-family: sans-serif; height: 100%; width: 100%; background: black; overflow: hidden; }
    .hidden-section { display: none !important; }

    /* --- CONTROLLER UI --- */
    .screen { display: none; padding: 20px; flex-direction: column; align-items: center; height: 100%; overflow-y: auto; background: #f4f4f4; box-sizing: border-box; }
    .active { display: flex; }
    .card { background: white; width: 100%; max-width: 420px; padding: 20px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); border: 1px solid #ddd; text-align: center; box-sizing: border-box; }

    button { width: 100%; padding: 12px; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; margin-top: 10px; }
    .btn-primary { background: #0070f3; color: white; }
    .btn-camera { background: #28a745; color: white; }
    .btn-stop { background: #ff4d4f; color: white; font-weight: bold; display: none; }
    .btn-dice { background: #666; color: white; margin-top: 15px; } 
    .btn-crop { background: #ff9800; color: white; font-weight: bold; margin-top: 15px; } /* Crop Button */

    .dice-btn-row { display: flex; gap: 5px; margin-top: 10px; }
    .btn-d3  { background: #f0ad4e; color: white; font-weight: bold; }
    .btn-d6  { background: #333; color: white; font-weight: bold; }
    .btn-d10 { background: #0275d8; color: white; font-weight: bold; }
    .btn-d20 { background: #d9534f; color: white; font-weight: bold; }

    .btn-calib { background: #111; color: white; font-weight: bold; display: none; }
    .btn-calib.on { background: #ff0080; }

    .btn-link-projector { display: block; width: 100%; padding: 12px; margin-top: 15px; background: #111; color: white; text-decoration: none; border-radius: 8px; text-align: center; font-weight: bold; box-sizing: border-box; }

    /* Inputs */
    input { width: 90%; padding: 10px; border: 1px solid #ccc; border-radius: 8px; margin-bottom: 10px; box-sizing: border-box; }
    .row { display: flex; justify-content: space-between; align-items: center; gap: 10px; margin: 10px 0; font-size: 13px; }
    .toggleBtn { width: auto; padding: 8px 10px; border-radius: 10px; background: #0070f3; color: white; font-weight: bold; margin-top: 0; }
    .toggleBtn.off { background: #ddd; color: #333; }
    
    .dual-input { display: flex; gap: 5px; align-items: center; }
    .dual-input input { width: 60px; text-align: center; font-weight: bold; margin: 0; }
    .label { font-size: 11px; color: #666; text-transform: uppercase; }

    ul { list-style: none; padding: 0; }
    li { padding: 10px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }

    /* VIDEO PREVIEW & CROP OVERLAY */
    #videoContainer { position: relative; width: 100%; margin-top: 10px; border-radius: 8px; overflow: hidden; background: #000; }
    #videoPreview { width: 100%; display: block; }
    
    /* This box overlays the video to show what is being cropped */
    #cropOverlay {
        position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; /* Let clicks pass through */
        box-shadow: inset 0 0 0 0 rgba(0,0,0,0.5); /* This gets updated by JS */
        border: 2px solid rgba(255, 255, 255, 0.5); /* Outer boundary */
        display: none;
    }
    /* The "Hole" is created by manipulating box-shadow in JS */

    #sendStatus { display: none; font-size: 12px; opacity: 0.75; margin-top: 8px; color: #0070f3; white-space: pre-line; }
    
    #calibPanel, #cropPanel { display: none; margin-top: 10px; padding: 12px; border-radius: 12px; border: 1px solid #eee; background: #fafafa; text-align: left; }
    #calibPanel h3, #cropPanel h3 { margin: 0 0 10px 0; font-size: 14px; }
    
    /* Crop Sliders */
    .slider-row { display: flex; align-items: center; justify-content: space-between; font-size: 12px; margin-bottom: 5px; }
    .slider-row input { width: 70%; margin: 0; padding: 0; }

    /* --- DICE STYLES --- */
    #diceTray { display: none; background: #eee; border-radius: 12px; padding: 15px; margin-top: 10px; border: 1px solid #ccc; }
    .dice-area { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-top: 15px; min-height: 40px; }
    .die-box { display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; border-radius: 6px; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); border: 2px solid rgba(255,255,255,0.5); }
    .type-D3  { background: #f0ad4e; color: black; }
    .type-D6  { background: #333; }
    .type-D10 { background: #0275d8; }
    .type-D20 { background: #d9534f; }
    .size-S { width: 30px; height: 30px; font-size: 14px; }
    .size-M { width: 50px; height: 50px; font-size: 22px; }
    .size-L { width: 80px; height: 80px; font-size: 36px; }

    /* --- PROJECTOR MODE STYLES --- */
    #projectorView { display: none; position: fixed; inset: 0; width: 100%; height: 100%; background: black; z-index: 9999; align-items: center; justify-content: center; }

    /* FUSED CONTAINER */
    #projectorContent {
        position: relative;
        width: 100px; height: 100px; 
        display: flex; justify-content: center; align-items: center;
    }

    /* IMAGE */
    #projectorImage {
      display: block; width: 100%; height: 100%;
      object-fit: fill; 
      z-index: 1;
    }

    /* GRID */
    #projectorGridCanvas { 
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
        z-index: 2; pointer-events: none; display: none; 
    }
    
    #projectorDiceOverlay { position: fixed; bottom: 20px; right: 20px; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 15px; z-index: 10002; display: none; pointer-events: none; border: 2px solid white; }
    #projectorDebug { color: #00ff00; font-family: monospace; font-size: 14px; position: absolute; top: 10px; left: 10px; z-index: 10001; background: rgba(0,0,0,0.5); padding: 10px; pointer-events: none; white-space: pre-line; }
    #fullscreenHint { color: rgba(255,255,255,0.5); font-size: 12px; position: absolute; bottom: 10px; width: 100%; text-align: center; pointer-events: none; z-index: 10001; }
    #projectorBlank { display: none; position: fixed; inset: 0; background: black; z-index: 10000; }
  </style>
</head>
<body>

  <div id="projectorView" ondblclick="toggleFullScreen()">
    <div id="projectorDebug">Initializing...</div>
    <div id="projectorContent">
        <img id="projectorImage" src="">
        <canvas id="projectorGridCanvas"></canvas>
    </div>
    <div id="projectorDiceOverlay">
        <div style="color:white; font-size:12px; margin-bottom:5px;">INCOMING ROLL:</div>
        <div id="projDiceContainer" class="dice-area" style="margin-top:0;"></div>
    </div>
    <div id="fullscreenHint">(Double-click screen for true fullscreen)</div>
  </div>

  <div id="projectorBlank"></div>

  <div id="mainInterface">
    <div id="lobbyScreen" class="screen active">
      <div class="card">
        <h2>üéÆ Game Hub</h2>
        <input type="text" id="playerIdInput" placeholder="Enter Your Name / ID" />
        <div id="hostSection">
          <hr>
          <input type="text" id="gameName" placeholder="Room Name...">
          <button class="btn-primary" onclick="hostGame()">Host Game</button>
        </div>
        <div id="joinSection">
          <hr>
          <ul id="gameList"><li>Searching...</li></ul>
        </div>
      </div>
    </div>

    <div id="roomScreen" class="screen">
      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <h2 id="roomTitle">Room</h2>
          <button style="width:auto; background:#ff4d4f; color:white; padding:5px 15px;" onclick="leaveGame()">EXIT</button>
        </div>
        <p>ID: <b id="roomCode">...</b></p>
        <a id="projectorLink" href="#" target="_blank" class="btn-link-projector">‚õ∂ Open Projector Tab</a>

        <hr>

        <button class="btn-camera" onclick="startCamera()">üì∑ Open Camera</button>
        
        <div id="videoContainer">
            <video id="videoPreview" autoplay playsinline></video>
            <div id="cropOverlay"></div>
        </div>

        <button id="startBtn" class="btn-primary" style="display:none;" onclick="startSending()">‚ñ∂ Start Auto-Send (30s)</button>
        <button id="stopBtn" class="btn-stop" onclick="stopSending()">‚ñ† Stop Sending</button>

        <button id="cropBtn" class="btn-crop" style="display:none;" onclick="toggleCropPanel()">‚úÇÔ∏è Crop Camera</button>
        
        <div id="cropPanel">
            <h3>Crop Settings (%)</h3>
            <div class="slider-row">
                <label>Top</label> <input type="range" id="cropTop" min="0" max="45" value="0" oninput="updateCrop()">
            </div>
            <div class="slider-row">
                <label>Bottom</label> <input type="range" id="cropBottom" min="0" max="45" value="0" oninput="updateCrop()">
            </div>
            <div class="slider-row">
                <label>Left</label> <input type="range" id="cropLeft" min="0" max="45" value="0" oninput="updateCrop()">
            </div>
            <div class="slider-row">
                <label>Right</label> <input type="range" id="cropRight" min="0" max="45" value="0" oninput="updateCrop()">
            </div>
            <div style="font-size:11px; color:#666; margin-top:5px;">
                Use sliders to cut out background. Only the clear area will be sent.
            </div>
        </div>

        <button class="btn-dice" onclick="toggleDiceTray()">üé≤ Open Dice Tray</button>
        <div id="diceTray">
            <div class="row">
                <span>Quantity:</span>
                <input type="number" id="diceQty" value="1" min="1" max="20" style="width:60px; margin:0; text-align:center;">
                <span>Display Size:</span>
                <select id="diceSize" style="padding:8px; border-radius:6px;">
                    <option value="S">Small</option>
                    <option value="M" selected>Medium</option>
                    <option value="L">Large</option>
                </select>
            </div>
            <p style="font-size:12px; color:#666; margin-bottom:5px;">Select Type to Roll:</p>
            <div class="dice-btn-row">
                <button class="btn-d3" onclick="rollDice(3, 'D3')">D3</button>
                <button class="btn-d6" onclick="rollDice(6, 'D6')">D6</button>
                <button class="btn-d10" onclick="rollDice(10, 'D10')">D10</button>
                <button class="btn-d20" onclick="rollDice(20, 'D20')">D20</button>
            </div>
            <div id="localDiceResults" class="dice-area"></div>
        </div>

        <button id="calibBtn" class="btn-calib" style="margin-top:15px;" onclick="toggleCalibrationMode()">üéØ Calibration Mode: OFF</button>

        <div id="calibPanel">
          <h3>Calibration Tools</h3>
          <div class="row">
            <div>Grid Overlay</div>
            <button id="gridToggleBtn" class="toggleBtn off" onclick="toggleGrid()">OFF</button>
          </div>
          <div class="row">
            <div>Square Dimensions</div>
            <div class="dual-input">
                <div>
                    <span class="label">Width</span>
                    <input id="gridWidthInput" type="number" min="10" max="400" value="50" oninput="onGridInput()">
                </div>
                <div>
                    <span class="label">Height</span>
                    <input id="gridHeightInput" type="number" min="10" max="400" value="50" oninput="onGridInput()">
                </div>
            </div>
          </div>
          <div style="font-size:11px; opacity:0.8; line-height:1.35; background:#eef; padding:8px; border-radius:8px;">
            <b>Calibration:</b> Adjust Width & Height until the projected square perfectly matches <b>1x1 inch</b> on your table.
          </div>
        </div>

        <div id="sendStatus"></div>
        <canvas id="canvas" style="display:none;"></canvas>
        <hr>
        <h3>Players:</h3>
        <ul id="playerList"></ul>
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    let currentRoomId = null;
    let cameraStream = null;
    let sendIntervalId = null;
    let myPlayerId = null;

    // Projector state
    let isProjectorMode = false;
    let projectorOwnerId = null;
    let projectorRoomId = null;
    
    // Calibration state
    let calibrationMode = false;
    let projectorViewMode = 'normal';

    const SEND_EVERY_MS = 30000;
    const STAGGER_JOIN_MS = 15000;
    
    // Grid Settings
    let gridEnabled = false;
    let gridW = 50;
    let gridH = 50;
    let projGridEnabled = false;
    let projGridW = 50;
    let projGridH = 50;
    
    // Crop Settings (Percentages 0-100)
    let crop = { t: 0, b: 0, l: 0, r: 0 };
    
    const GRID_COLS = 30; 
    const GRID_ROWS = 22;

    window.onload = function() {
      const params = new URLSearchParams(window.location.search);
      const mode = params.get('mode');

      if (mode === 'projector') {
        isProjectorMode = true;
        projectorRoomId = params.get('room');
        projectorOwnerId = params.get('owner');

        document.getElementById('mainInterface').style.display = 'none';
        document.getElementById('projectorView').style.display = 'flex';
        updateDebug(`Projector Active\nOwner: ${projectorOwnerId}\nMode: normal`);
        
        // Init canvas
        const c = document.getElementById('projectorGridCanvas');
        c.width = 100; c.height = 100; // Placeholder

        if (projectorRoomId && projectorOwnerId) {
          socket.emit('joinAsProjector', { roomId: projectorRoomId, ownerId: projectorOwnerId });
        }
        return;
      }

      if (mode === 'host') document.getElementById('joinSection').classList.add('hidden-section');
      else if (mode === 'join') document.getElementById('hostSection').classList.add('hidden-section');

      loadGridPrefs();
      syncGridPanelUI();
    };

    // --- CROP LOGIC ---
    function toggleCropPanel() {
        const panel = document.getElementById('cropPanel');
        const overlay = document.getElementById('cropOverlay');
        if (panel.style.display === 'block') {
            panel.style.display = 'none';
            overlay.style.display = 'none';
        } else {
            panel.style.display = 'block';
            overlay.style.display = 'block';
            updateCropOverlay(); // refresh visuals
        }
    }

    function updateCrop() {
        crop.t = parseInt(document.getElementById('cropTop').value);
        crop.b = parseInt(document.getElementById('cropBottom').value);
        crop.l = parseInt(document.getElementById('cropLeft').value);
        crop.r = parseInt(document.getElementById('cropRight').value);
        updateCropOverlay();
    }

    function updateCropOverlay() {
        const overlay = document.getElementById('cropOverlay');
        // We use inset box-shadow to darken the cropped area
        // Order: Top Right Bottom Left
        // But box-shadow inset doesn't support 4 distinct sides easily without overlap weirdness.
        // Easier approach: clip-path? Or simple borders?
        // Let's use border-width. 
        // NOTE: border-width uses pixels usually, but we have percentages.
        // Actually, easiest way to visualize crop on a fluid element is `clip-path`'s inverse or 4 divs.
        // Let's use `box-shadow` on a centered transparent div.
        
        // A simple visual trick: Set box-shadow to be huge, but inset.
        // Wait, box-shadow inset applies to the inside. 
        // Let's just adjust the `top/left/right/bottom` properties of the overlay to MATCH the crop, and give it a border.
        
        overlay.style.top = crop.t + "%";
        overlay.style.bottom = crop.b + "%";
        overlay.style.left = crop.l + "%";
        overlay.style.right = crop.r + "%";
        
        // The overlay represents the KEPT area.
        // We want to darken the outside. We can do this by giving the overlay a huge outline.
        overlay.style.outline = "1000px solid rgba(0,0,0,0.6)";
    }

    // --- DICE LOGIC ---
    function toggleDiceTray() {
        const tray = document.getElementById('diceTray');
        const btn = document.querySelector('.btn-dice');
        if (tray.style.display === 'block') { tray.style.display = 'none'; btn.innerText = "üé≤ Open Dice Tray"; }
        else { tray.style.display = 'block'; btn.innerText = "üé≤ Close Dice Tray"; }
    }
    function rollDice(sides, typeName) {
        if (!currentRoomId) return alert("Join a room first!");
        const qty = parseInt(document.getElementById('diceQty').value);
        const size = document.getElementById('diceSize').value;
        const results = [];
        for(let i=0; i<qty; i++) results.push(Math.floor(Math.random() * sides) + 1);
        const diceData = { results, size, type: typeName };
        renderDice(diceData, 'localDiceResults');
        socket.emit('rollDice', { roomId: currentRoomId, dice: diceData, senderId: myPlayerId });
    }
    function renderDice(diceData, containerId) {
        const container = document.getElementById(containerId);
        container.innerHTML = ''; 
        diceData.results.forEach(num => {
            const die = document.createElement('div');
            die.className = `die-box type-${diceData.type} size-${diceData.size}`;
            die.innerText = num;
            container.appendChild(die);
        });
    }

    // --- UTILS ---
    function updateProjectorLink() {
      if (!currentRoomId || !myPlayerId) return;
      const url = `${window.location.origin}/?mode=projector&room=${encodeURIComponent(currentRoomId)}&owner=${encodeURIComponent(myPlayerId)}`;
      document.getElementById('projectorLink').href = url;
    }
    function updateDebug(msg) { const el = document.getElementById('projectorDebug'); if(el) el.innerText = msg; }
    function setStatus(msg) { const el = document.getElementById('sendStatus'); el.style.display = msg?'block':'none'; el.innerText=msg||''; }
    function toggleFullScreen() {
      const d=document; const e=d.documentElement;
      (d.fullscreenElement?d.exitFullscreen:e.requestFullscreen).call(d.fullscreenElement?d:e);
    }

    // --- PROJECTOR CONTROLS ---
    function setProjectorViewMode(mode) { if(currentRoomId) socket.emit('setProjectorViewMode', { roomId: currentRoomId, ownerId: myPlayerId, mode }); }
    
    function sendGridUpdate() { 
        if(!currentRoomId) return;
        socket.emit('setProjectorGrid', { 
            roomId: currentRoomId, 
            ownerId: myPlayerId, 
            enabled: !!gridEnabled, 
            width: parseInt(gridW),
            height: parseInt(gridH)
        }); 
    }
    
    function toggleCalibrationMode() {
      calibrationMode = !calibrationMode;
      const btn = document.getElementById('calibBtn');
      const panel = document.getElementById('calibPanel');
      if (calibrationMode) {
        btn.classList.add('on'); btn.innerText = "üéØ Calibration Mode: ON"; panel.style.display = 'block';
        setStatus("Calibration ON: Projector shows YOUR camera feed.");
        setProjectorViewMode('calibrate'); 
        sendGridUpdate();
      } else {
        btn.classList.remove('on'); btn.innerText = "üéØ Calibration Mode: OFF"; panel.style.display = 'none';
        setStatus("Calibration OFF: Projector shows opponent.");
        setProjectorViewMode('normal'); 
        socket.emit('setProjectorGrid', { roomId: currentRoomId, ownerId: myPlayerId, enabled: false, width: gridW, height: gridH });
      }
    }

    // --- CAMERA & SENDING ---
    function startCamera() {
      navigator.mediaDevices.getUserMedia({ video: true, audio: false }).then(s => {
        cameraStream = s;
        const v = document.getElementById('videoPreview'); v.srcObject = s; v.style.display = 'block';
        document.getElementById('startBtn').style.display = 'block';
        document.getElementById('calibBtn').style.display = 'block';
        document.getElementById('cropBtn').style.display = 'block';
      }).catch(() => alert("Camera blocked!"));
    }

    function drawCenterDot(ctx, w, h) {
      const cx = w/2, cy = h/2;
      ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI*2); ctx.strokeStyle="rgba(255,255,255,0.8)"; ctx.lineWidth=3; ctx.stroke();
      ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI*2); ctx.fillStyle="rgba(255,0,0,1)"; ctx.fill();
    }

    function captureAndSendFrame() {
      if (!cameraStream || !currentRoomId) return;
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const video = document.getElementById('videoPreview');
      
      // Canvas size (resolution of sent image)
      canvas.width = 1280; canvas.height = 720;
      
      // CROP MATH
      const vidW = video.videoWidth;
      const vidH = video.videoHeight;
      if (!vidW || !vidH) return; // Video not ready

      // Calculate Source (Camera) Coordinates based on percentages
      const sx = (crop.l / 100) * vidW;
      const sy = (crop.t / 100) * vidH;
      const sWidth = vidW - ((crop.l + crop.r) / 100) * vidW;
      const sHeight = vidH - ((crop.t + crop.b) / 100) * vidH;

      // Draw from Crop Source -> To Full Canvas Destination
      // This effectively "Zooms" the cropped area to fill the output
      ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, canvas.width, canvas.height);

      if (calibrationMode) drawCenterDot(ctx, canvas.width, canvas.height);
      socket.emit('sendImage', { roomId: currentRoomId, image: canvas.toDataURL('image/jpeg', 0.6) });
      setStatus(`Sent snapshot at ${new Date().toLocaleTimeString()}`);
    }

    function captureAndSendWithBlank() {
      captureAndSendFrame();
    }

    function startSending() {
      if (!cameraStream || !currentRoomId) return alert("Setup first!");
      if (sendIntervalId) return;
      const d = (new URLSearchParams(window.location.search).get('mode') === 'join') ? STAGGER_JOIN_MS : 0;
      setStatus(d ? `Starting in ${d/1000}s...` : "Starting...");
      setTimeout(() => {
        captureAndSendWithBlank();
        sendIntervalId = setInterval(captureAndSendWithBlank, SEND_EVERY_MS);
        document.getElementById('startBtn').style.display = 'none';
        document.getElementById('stopBtn').style.display = 'block';
      }, d);
    }

    function stopSending() {
      if (sendIntervalId) clearInterval(sendIntervalId);
      sendIntervalId = null;
      document.getElementById('stopBtn').style.display = 'none';
      document.getElementById('startBtn').style.display = 'block';
      setStatus("Stopped.");
    }

    // --- GRID UI ---
    function toggleGrid() { gridEnabled = !gridEnabled; syncGridPanelUI(); if(calibrationMode) sendGridUpdate(); }
    function onGridInput() { 
        const wVal = parseInt(document.getElementById('gridWidthInput').value);
        const hVal = parseInt(document.getElementById('gridHeightInput').value);
        if(wVal) gridW = Math.max(10, Math.min(400, wVal));
        if(hVal) gridH = Math.max(10, Math.min(400, hVal));
        saveGridPrefs();
        if(calibrationMode) sendGridUpdate(); 
    }
    function loadGridPrefs() { 
        gridEnabled=(localStorage.getItem("wg_grid_enabled")==="true"); 
        gridW=parseInt(localStorage.getItem("wg_grid_w")||"50"); 
        gridH=parseInt(localStorage.getItem("wg_grid_h")||"50"); 
    }
    function saveGridPrefs() {
        localStorage.setItem("wg_grid_enabled", gridEnabled); 
        localStorage.setItem("wg_grid_w", gridW);
        localStorage.setItem("wg_grid_h", gridH);
    }
    function syncGridPanelUI() {
      document.getElementById('gridToggleBtn').classList.toggle('off', !gridEnabled);
      document.getElementById('gridToggleBtn').innerText = gridEnabled ? "ON" : "OFF";
      document.getElementById('gridWidthInput').value = gridW;
      document.getElementById('gridHeightInput').value = gridH;
    }

    // --- PROJECTOR RENDER LOGIC ---
    function updateProjectorLayout() {
        if (!isProjectorMode) return;
        const targetW = GRID_COLS * projGridW;
        const targetH = GRID_ROWS * projGridH;
        
        const container = document.getElementById('projectorContent');
        container.style.width = targetW + 'px';
        container.style.height = targetH + 'px';
        
        const c = document.getElementById('projectorGridCanvas');
        c.width = targetW; c.height = targetH;
        
        const ctx = c.getContext('2d');
        ctx.clearRect(0,0,targetW,targetH);
        
        if (!projGridEnabled) return;
        c.style.display='block';
        
        ctx.lineWidth=1; ctx.strokeStyle="white"; ctx.globalAlpha=0.6;
        for(let x=0; x<=GRID_COLS; x++) { 
            const xPos = x * projGridW;
            ctx.beginPath(); ctx.moveTo(xPos, 0); ctx.lineTo(xPos, targetH); ctx.stroke(); 
        }
        for(let y=0; y<=GRID_ROWS; y++) { 
            const yPos = y * projGridH;
            ctx.beginPath(); ctx.moveTo(0, yPos); ctx.lineTo(targetW, yPos); ctx.stroke(); 
        }
        ctx.lineWidth=2; ctx.strokeStyle="#00ff00"; ctx.globalAlpha=0.8;
        const midX = (GRID_COLS/2) * projGridW;
        ctx.beginPath(); ctx.moveTo(midX, 0); ctx.lineTo(midX, targetH); ctx.stroke();
        const midY = (GRID_ROWS/2) * projGridH;
        ctx.beginPath(); ctx.moveTo(0, midY); ctx.lineTo(targetW, midY); ctx.stroke();
        ctx.globalAlpha=1;
    }

    // --- SOCKET HANDLERS ---
    socket.on('errorMsg', alert);
    socket.on('projectorBlank', ({blank}) => { if(isProjectorMode) document.getElementById('projectorBlank').style.display = blank?'block':'none'; });
    socket.on('projectorViewMode', ({mode}) => { if(isProjectorMode) { projectorViewMode=mode; updateDebug(`Projector Active\nOwner: ${projectorOwnerId}\nMode: ${mode}`); } });
    
    // Filter by Owner ID
    socket.on('projectorGrid', ({ownerId, enabled, width, height}) => { 
        if(isProjectorMode && ownerId === projectorOwnerId) { 
            projGridEnabled=enabled; 
            projGridW = width || 50;
            projGridH = height || 50;
            updateProjectorLayout();
            document.getElementById('projectorGridCanvas').style.display = enabled?'block':'none'; 
        } 
    });
    
    socket.on('receiveImage', ({image, senderId}) => {
      if (!isProjectorMode) return;
      if (projectorViewMode === 'normal' && senderId === projectorOwnerId) return;
      if (projectorViewMode === 'calibrate' && senderId !== projectorOwnerId) return;
      document.getElementById('projectorImage').src = image;
      document.getElementById('fullscreenHint').style.display = 'none';
    });
    
    socket.on('diceRolled', ({ dice, senderId }) => {
        if (isProjectorMode) {
            const overlay = document.getElementById('projectorDiceOverlay');
            overlay.style.display = 'block';
            renderDice(dice, 'projDiceContainer');
            setTimeout(() => { overlay.style.display = 'none'; }, 8000);
        }
    });

    // --- STANDARD GAME LOGIC ---
    function getPlayerId() { return document.getElementById('playerIdInput').value.trim(); }
    function hostGame() { const n = document.getElementById('gameName').value.trim(); myPlayerId = getPlayerId(); if(n && myPlayerId) socket.emit('hostGame', {name:n, playerId:myPlayerId}); }
    function joinGame(id) { myPlayerId = getPlayerId(); if(myPlayerId) socket.emit('joinGame', {roomId:id, playerId:myPlayerId}); }
    function leaveGame() { if(currentRoomId) socket.emit('leaveGame', currentRoomId); }
    socket.on('updateGameList', (g) => {
      const l = document.getElementById('gameList'); l.innerHTML = '';
      Object.values(g).forEach(r => l.innerHTML += `<li><b>${r.name}</b> <button class="btn-primary" style="width:auto; padding:5px;" onclick="joinGame('${r.id}')">Join</button></li>`);
    });
    socket.on('joinedRoom', (r) => {
      currentRoomId = r.id;
      document.getElementById('lobbyScreen').classList.remove('active');
      document.getElementById('roomScreen').classList.add('active');
      document.getElementById('roomTitle').innerText = r.name;
      document.getElementById('roomCode').innerText = r.id;
      document.getElementById('playerList').innerHTML = r.players.map(p => `<li>üë§ ${p}</li>`).join('');
      updateProjectorLink();
      calibrationMode = false;
      document.getElementById('calibBtn').classList.remove('on');
      document.getElementById('calibPanel').style.display = 'none';
      setProjectorViewMode('normal');
    });
    socket.on('playerUpdate', (p) => document.getElementById('playerList').innerHTML = p.map(u => `<li>üë§ ${u}</li>`).join(''));
    socket.on('backToLobby', () => {
      currentRoomId = null; stopSending();
      document.getElementById('roomScreen').classList.remove('active');
      document.getElementById('lobbyScreen').classList.add('active');
      if (cameraStream) cameraStream.getTracks().forEach(t => t.stop()); cameraStream = null;
      projGridEnabled=false;
    });
  </script>
</body>
</html>
